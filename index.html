<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thomas and Friends S3 EP/GP</title>
    
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Use the Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Include Heroicons for the sort arrows -->
    <script src="https://unpkg.com/heroicons@2.1.3/dist/24/outline/index.js"></script>

    <!-- Wowhead Tooltips Script -->
    <script src="https://wow.zamimg.com/widgets/power.js"></script>
    <script>var wowhead_tooltips = { "colorlinks": false, "iconizelinks": true, "renamelinks": true }</script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d0d; /* Almost black */
            color: #f5f5f5;
        }
        
        /* A simple scrollbar style for the table */
        .table-container::-webkit-scrollbar {
            height: 8px;
        }
        .table-container::-webkit-scrollbar-track {
            background: #1c1c1c;
            border-radius: 10px;
        }
        .table-container::-webkit-scrollbar-thumb {
            background: #e32636;
            border-radius: 10px;
        }

        .quality-6 { color: #f59e0b; } /* Legendary - Amber */
        .quality-5 { color: #a855f7; } /* Epic - Purple */
        .quality-4 { color: #2563eb; } /* Rare - Blue */
        .quality-3 { color: #10b981; } /* Uncommon - Emerald */

        .ep-points { color: #10b981; } /* Emerald */
        .gp-points { color: #f59e0b; } /* Amber */
        .decay-points { color: #e32636; } /* Red */
    </style>
</head>
<body class="p-6 md:p-10 flex flex-col items-center justify-center min-h-screen">

    <!-- Main application container -->
    <div id="app" class="w-full max-w-4xl bg-[#1c1c1c] rounded-2xl shadow-xl p-8 md:p-12">
        <h1 class="text-3xl md:text-4xl font-bold text-[#e32636] mb-6 text-center">
            Season 3 EP/GP
        </h1>
        
        <!-- Status and user information display area -->
        <div id="status-message" class="text-center text-sm md:text-base mb-4 font-bold text-gray-300">
            <!-- Status messages, user info, and login/logout links will appear here -->
        </div>

        <!-- The main application view will be dynamically rendered here -->
        <div id="app-view">
            <!-- This content will be replaced by either the admin or public view -->
            <p class="text-center text-gray-400">Loading...</p>
        </div>
    </div>
    
    <!-- Firebase Libraries (loaded from a CDN) -->
    <script type="module">
        // Import all the necessary Firebase functions
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, getDoc, collection, addDoc, getDocs, query, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // The firebaseConfig object has been updated with your details.
        const firebaseConfig = {
          apiKey: "FIREBASE_API_KEY_PLACEHOLDER",
          authDomain: "thomas-and-friends-raid-epgp.firebaseapp.com",
          projectId: "thomas-and-friends-raid-epgp",
          storageBucket: "thomas-and-friends-raid-epgp.firebasestorage.app",
          messagingSenderId: "1041751724978",
          appId: "1:104171724978:web:8728200dfe9f749a39caab",
          measurementId: "G-CR1BDVMN2V"
        };

        // Your application ID, used for the Firestore path.
        const appId = "t-and-f-epgp";
        
        // Global variables for Firebase services and user data
        let db;
        let auth;
        let userId = null;
        let isAdmin = false;
        let adminsList = [];
        
        // State for sorting the roster table
        let currentSort = { column: 'pr', direction: 'desc' };

        // Global state for history data and filters
        let allPointHistory = [];
        let allLootHistory = [];
        let rosterData = [];
        let pointFilter = '';
        let lootFilter = '';


        // Helper function to show a message to the user
        function showStatusMessage(message, isError = false) {
            const statusDiv = document.getElementById('status-message');
            statusDiv.innerHTML = message;
            statusDiv.className = `text-center text-sm md:text-base mb-4 font-bold ${isError ? 'text-red-400' : 'text-green-400'}`;
        }
        
        // Initialize Firebase and set up the authentication state listener
        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Listen for authentication state changes and handle all logic from here
                onAuthStateChanged(auth, async (user) => {
                    userId = user ? user.uid : null;
                    console.log("Auth state changed. User ID:", userId);
                    
                    try {
                        // Fetch the list of admin UIDs from Firestore only after auth state is known
                        const adminsRef = doc(db, `artifacts/${appId}/public/data/roles`, 'admins');
                        const docSnap = await getDoc(adminsRef);
                        if (docSnap.exists()) {
                            adminsList = docSnap.data().uids;
                        } else {
                            console.error("Admin UIDs document not found.");
                            adminsList = [];
                        }
                    } catch (error) {
                        console.error("Error fetching admin list:", error);
                        adminsList = [];
                    }

                    isAdmin = userId && adminsList.includes(userId);
                    console.log("Is Admin:", isAdmin);
                    renderApp();
                });

            } catch (error) {
                showStatusMessage("Error initializing Firebase. Please check your configuration.", true);
                console.error("Firebase initialization error: ", error);
            }
        }
        
        // This function decides which view to render based on the user's role.
        function renderApp() {
            if (isAdmin) {
                renderAdminView();
            } else {
                renderPublicView();
            }
        }

        // ======================== AUTHENTICATION FUNCTIONS ========================
        async function signInAdmin() {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Error during sign-in:", error);
                // The new, more descriptive error message will be shown on the page
                showStatusMessage("Login failed. This may be due to an incorrect Firebase configuration or because your app's domain is not on the list of authorized domains in your Firebase project.", true);
            }
        }
        
        async function signOutUser() {
            try {
                await signOut(auth);
                showStatusMessage("You have been signed out.", false);
            } catch (error) {
                console.error("Error during sign-out:", error);
                showStatusMessage("Logout failed. Please try again.", true);
            }
        }

        // A helper function to clear all documents from a collection
        async function clearCollection(collectionRef) {
            const q = query(collectionRef);
            const querySnapshot = await getDocs(q);
            const deletePromises = [];
            querySnapshot.forEach((doc) => {
                deletePromises.push(deleteDoc(doc.ref));
            });
            await Promise.all(deletePromises);
        }
        
        // ======================== ADMIN VIEW ========================
        function renderAdminView() {
            const appView = document.getElementById('app-view');
            appView.innerHTML = `
                <div class="space-y-4">
                    <p class="text-center text-gray-400 text-sm">
                        Welcome, Raid Lead! Your User ID is: <span class="font-mono text-[#e32636] text-xs md:text-sm break-all">${userId}</span>
                        <br>
                        Add this ID to the 'admins' document in your Firestore project to enable updates.
                    </p>
                    <textarea id="data-paste-area" class="w-full h-48 p-4 bg-gray-900 text-gray-200 border-2 border-[#e32636] rounded-lg focus:outline-none focus:border-[#e32636]" placeholder="Paste your EP/GP addon JSON data here. The app is looking for a nested structure like: rawData.standings.roster[0].standings.player..."></textarea>
                    <button id="save-button" class="w-full bg-[#e32636] text-white font-bold py-3 rounded-lg hover:bg-red-600 transition-colors">
                        Save Roster Data
                    </button>
                    <p class="text-center text-gray-400 mt-4">
                        <a href="#" id="view-roster-link" class="underline hover:text-[#e32636]">View the public roster</a> | 
                        <a href="#" id="logout-link" class="underline hover:text-[#e32636]">Logout</a>
                    </p>
                </div>
            `;
            
            document.getElementById('save-button').addEventListener('click', saveData);
            document.getElementById('view-roster-link').addEventListener('click', renderPublicView);
            document.getElementById('logout-link').addEventListener('click', signOutUser);
        }

        // Handles the process of saving data to Firestore
        async function saveData() {
            const dataArea = document.getElementById('data-paste-area');
            const dataString = dataArea.value;

            if (!dataString) {
                showStatusMessage("Please paste data before saving.", true);
                return;
            }
            
            let rawData;
            try {
                rawData = JSON.parse(dataString);
            } catch (e) {
                showStatusMessage("Error: The text you pasted is not a valid JSON format.", true);
                return;
            }

            console.log("Parsed JSON Data:", rawData);

            try {
                // Safely access the nested player, point, and loot history data.
                const roster = rawData?.standings?.roster?.[0]?.standings?.player;
                const pointHistory = rawData?.pointHistory?.roster?.[0]?.pointHistory?.point;
                const lootHistory = rawData?.lootHistory?.roster?.[0]?.lootHistory?.item;

                if (!roster) {
                    showStatusMessage("Error: Could not find player data at the expected path: `standings.roster[0].standings.player`. Please check your JSON format.", true);
                    return;
                }
                
                console.log("Extracted Roster:", roster);
                console.log("Extracted Point History:", pointHistory);
                console.log("Extracted Loot History:", lootHistory);

                // --- 1. Save Roster Data ---
                // Map the complex roster array into the simple format our table expects
                const formattedRoster = roster.map(p => ({
                    name: p.name,
                    ep: p.points,
                    gp: p.spent
                }));

                const rosterRef = doc(db, `artifacts/${appId}/public/data/rosters`, 'guild_roster');
                await setDoc(rosterRef, {
                    roster: formattedRoster,
                    lastUpdated: new Date().toISOString()
                });
                
                // --- 2. Save Point History Data ---
                const pointHistoryCollectionRef = collection(db, `artifacts/${appId}/public/data/point_history_items`);
                // Clear the existing collection to prevent duplicates
                await clearCollection(pointHistoryCollectionRef);
                
                if (pointHistory && Array.isArray(pointHistory)) {
                    // Iterate and add each point history entry as a separate document
                    const addPromises = pointHistory.map(point => addDoc(pointHistoryCollectionRef, point));
                    await Promise.all(addPromises);
                }
                
                // --- 3. Save Loot History Data ---
                const lootHistoryCollectionRef = collection(db, `artifacts/${appId}/public/data/loot_history_items`);
                // Clear the existing collection to prevent duplicates
                await clearCollection(lootHistoryCollectionRef);
                
                if (lootHistory && Array.isArray(lootHistory)) {
                    // Iterate and add each loot history entry as a separate document
                    const addPromises = lootHistory.map(item => addDoc(lootHistoryCollectionRef, item));
                    await Promise.all(addPromises);
                }
                
                showStatusMessage("Roster, Point History, and Loot History data saved successfully!", false);
                dataArea.value = ''; // Clear the text area after successful save
                
                // Switch to the public view to show the new data
                renderPublicView();
            } catch (e) {
                showStatusMessage("An unexpected error occurred while saving. Please check the browser console for details.", true);
                console.error("Error saving document:", e);
            }
        }
        
        // ======================== PUBLIC VIEW ========================
        function renderPublicView() {
            const appView = document.getElementById('app-view');
            
            let authLink = isAdmin ?
                `<a href="#" id="logout-link" class="underline hover:text-[#e32636]">Logout</a>` :
                `<a href="#" id="admin-login-link" class="underline hover:text-[#e32636]">Are you the Raid Lead? Log in to update.</a>`;

            appView.innerHTML = `
                <div class="space-y-6">
                    <p class="text-center text-gray-400 text-sm">
                        You are viewing the latest guild roster. ${authLink}
                    </p>
                    <div id="last-updated-display" class="text-sm md:text-base text-gray-400 text-center">
                        <!-- Last updated timestamp will go here -->
                    </div>
                    
                    <!-- Roster Table Section -->
                    <h2 class="text-2xl font-bold text-[#e32636] mb-4">Roster</h2>
                    <div id="roster-table-container" class="bg-gray-900 p-4 rounded-lg overflow-x-auto table-container">
                        <p class="text-center text-gray-400">Fetching roster data...</p>
                    </div>

                    <!-- Point History Section -->
                    <h2 class="text-2xl font-bold text-[#e32636] mb-4 mt-8 flex items-center justify-between">
                        Point History
                        <div class="text-base text-gray-400 font-normal">
                            Filter by Player:
                            <select id="point-player-filter" class="ml-2 p-1 rounded-md bg-gray-800 text-white cursor-pointer"></select>
                        </div>
                    </h2>
                    <div id="point-history-container" class="bg-gray-900 p-4 rounded-lg overflow-x-auto table-container">
                        <p class="text-center text-gray-400">Fetching point history...</p>
                    </div>

                    <!-- Loot History Section -->
                    <h2 class="text-2xl font-bold text-[#e32636] mb-4 mt-8 flex items-center justify-between">
                        Loot History
                        <div class="text-base text-gray-400 font-normal">
                            Filter by Player:
                            <select id="loot-player-filter" class="ml-2 p-1 rounded-md bg-gray-800 text-white cursor-pointer"></select>
                        </div>
                    </h2>
                    <div id="loot-history-container" class="bg-gray-900 p-4 rounded-lg overflow-x-auto table-container">
                        <p class="text-center text-gray-400">Fetching loot history...</p>
                    </div>
                </div>
            `;
            
            if (isAdmin) {
                document.getElementById('logout-link').addEventListener('click', signOutUser);
            } else {
                document.getElementById('admin-login-link').addEventListener('click', signInAdmin);
            }
            
            // Set up a real-time listener for the roster data
            const rosterRef = doc(db, `artifacts/${appId}/public/data/rosters`, 'guild_roster');
            onSnapshot(rosterRef, (docSnap) => {
                const tableContainer = document.getElementById('roster-table-container');
                const lastUpdatedDisplay = document.getElementById('last-updated-display');

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    rosterData = data.roster; // Store the roster data globally
                    displayRosterTable(rosterData, tableContainer);
                    lastUpdatedDisplay.innerHTML = `Last Updated: ${new Date(data.lastUpdated).toLocaleString()}`;
                    
                    // Populate the filter dropdowns once the roster is loaded
                    populatePlayerFilters(rosterData);
                    
                } else {
                    tableContainer.innerHTML = '<p class="text-center text-gray-400">No roster data found yet. Please ask the Raid Lead to upload data.</p>';
                    rosterData = [];
                }
                
                // Re-display history tables with the (possibly new) roster data
                updatePointHistoryDisplay();
                updateLootHistoryDisplay();
            }, (error) => {
                const tableContainer = document.getElementById('roster-table-container');
                tableContainer.innerHTML = '<p class="text-center text-red-400">Error fetching data. Please try again later.</p>';
                console.error("Error fetching roster: ", error);
            });
            
            // Set up a real-time listener for the point history
            const pointHistoryCollectionRef = collection(db, `artifacts/${appId}/public/data/point_history_items`);
            onSnapshot(pointHistoryCollectionRef, (querySnapshot) => {
                if (!querySnapshot.empty) {
                    allPointHistory = [];
                    querySnapshot.forEach(doc => allPointHistory.push(doc.data()));
                    updatePointHistoryDisplay();
                } else {
                    allPointHistory = [];
                    updatePointHistoryDisplay();
                }
            }, (error) => {
                const container = document.getElementById('point-history-container');
                container.innerHTML = '<p class="text-center text-red-400">Error fetching point history.</p>';
                console.error("Error fetching point history: ", error);
            });
            
            // Set up a real-time listener for the loot history
            const lootHistoryCollectionRef = collection(db, `artifacts/${appId}/public/data/loot_history_items`);
            onSnapshot(lootHistoryCollectionRef, (querySnapshot) => {
                if (!querySnapshot.empty) {
                    allLootHistory = [];
                    querySnapshot.forEach(doc => allLootHistory.push(doc.data()));
                    updateLootHistoryDisplay();
                } else {
                    allLootHistory = [];
                    updateLootHistoryDisplay();
                }
            }, (error) => {
                const container = document.getElementById('loot-history-container');
                container.innerHTML = '<p class="text-center text-red-400">Error fetching loot history.</p>';
                console.error("Error fetching loot history: ", error);
            });

            // Add event listeners for the filter dropdowns
            document.getElementById('point-player-filter').addEventListener('change', (e) => {
                pointFilter = e.target.value;
                updatePointHistoryDisplay();
            });

            document.getElementById('loot-player-filter').addEventListener('change', (e) => {
                lootFilter = e.target.value;
                updateLootHistoryDisplay();
            });
        }
        
        // Helper function to populate the filter dropdowns
        function populatePlayerFilters(players) {
            const pointFilterSelect = document.getElementById('point-player-filter');
            const lootFilterSelect = document.getElementById('loot-player-filter');

            // Clear previous options
            pointFilterSelect.innerHTML = '<option value="">All Players</option>';
            lootFilterSelect.innerHTML = '<option value="">All Players</option>';

            const playerNames = players.map(p => p.name).sort();
            playerNames.forEach(name => {
                pointFilterSelect.innerHTML += `<option value="${name}">${name}</option>`;
                lootFilterSelect.innerHTML += `<option value="${name}">${name}</option>`;
            });
            
            // Restore the last selected values if they exist
            pointFilterSelect.value = pointFilter;
            lootFilterSelect.value = lootFilter;
        }

        // Helper function to update the point history display with the current filter
        function updatePointHistoryDisplay() {
            const container = document.getElementById('point-history-container');
            let filteredHistory = allPointHistory;

            if (pointFilter) {
                filteredHistory = allPointHistory.filter(p => p.player === pointFilter);
            }

            displayPointHistoryTable(filteredHistory, container);
        }

        // Helper function to update the loot history display with the current filter
        function updateLootHistoryDisplay() {
            const container = document.getElementById('loot-history-container');
            let filteredHistory = allLootHistory;

            if (lootFilter) {
                filteredHistory = allLootHistory.filter(l => l.player === lootFilter);
            }

            displayLootHistoryTable(filteredHistory, container);
        }

        // A helper function to build and display the roster table with interactive sorting
        function displayRosterTable(rosterData, container) {
            if (!rosterData || rosterData.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-400">No roster data to display.</p>';
                return;
            }

            // Create a copy to avoid mutating the original data
            const mutableRoster = [...rosterData].map(p => ({
                ...p,
                // Ensure PR is always a number for sorting
                pr: p.gp > 0 ? (p.ep / p.gp) : -1 // Use a sentinel value for N/A
            }));
            
            // Sort the roster based on the current sort state
            mutableRoster.sort((a, b) => {
                let aVal, bVal;

                if (currentSort.column === 'pr') {
                    aVal = a.pr;
                    bVal = b.pr;
                } else if (currentSort.column === 'name') {
                    aVal = a.name.toLowerCase();
                    bVal = b.name.toLowerCase();
                } else {
                    aVal = a[currentSort.column];
                    bVal = b[currentSort.column];
                }

                if (aVal < bVal) return currentSort.direction === 'asc' ? -1 : 1;
                if (aVal > bVal) return currentSort.direction === 'asc' ? 1 : -1;
                return 0;
            });
            
            // Function to get the sort icon for a given column
            const getSortIcon = (column) => {
                if (currentSort.column === column) {
                    return currentSort.direction === 'asc' ? 
                        `<svg class="w-4 h-4 ml-2 inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" /></svg>` :
                        `<svg class="w-4 h-4 ml-2 inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>`;
                }
                return '';
            };

            let tableHTML = `
                <table class="w-full text-left rounded-lg overflow-hidden">
                    <thead class="bg-[#e32636] text-white">
                        <tr>
                            <th id="sort-name" class="p-3 cursor-pointer select-none whitespace-nowrap">Player${getSortIcon('name')}</th>
                            <th id="sort-ep" class="p-3 cursor-pointer select-none whitespace-nowrap">EP${getSortIcon('ep')}</th>
                            <th id="sort-gp" class="p-3 cursor-pointer select-none whitespace-nowrap">GP${getSortIcon('gp')}</th>
                            <th id="sort-pr" class="p-3 cursor-pointer select-none whitespace-nowrap">PR${getSortIcon('pr')}</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            mutableRoster.forEach(player => {
                tableHTML += `
                    <tr class="border-b border-gray-700 last:border-b-0 even:bg-gray-800">
                        <td class="p-3">${player.name}</td>
                        <td class="p-3">${player.ep}</td>
                        <td class="p-3">${player.gp}</td>
                        <td class="p-3">${player.pr === -1 ? 'N/A' : player.pr.toFixed(2)}</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            container.innerHTML = tableHTML;

            // Attach event listeners to the headers for sorting
            ['name', 'ep', 'gp', 'pr'].forEach(column => {
                const header = document.getElementById(`sort-${column}`);
                if (header) {
                    header.addEventListener('click', () => {
                        // If it's the same column, toggle the direction. Otherwise, default to descending.
                        if (currentSort.column === column) {
                            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort.column = column;
                            currentSort.direction = 'desc'; // Default sort direction
                        }
                        
                        // Re-render the table with the new sort state
                        displayRosterTable(rosterData, container);
                    });
                }
            });
        }
        
        // NOTE: This function now receives an array of point objects directly
        function displayPointHistoryTable(historyData, container) {
            if (!historyData || historyData.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-400">No point history to display.</p>';
                return;
            }

            let tableHTML = `
                <table class="w-full text-left rounded-lg overflow-hidden">
                    <thead class="bg-[#e32636] text-white">
                        <tr>
                            <th class="p-3">Time</th>
                            <th class="p-3">Player</th>
                            <th class="p-3">Points</th>
                            <th class="p-3">Reason</th>
                            <th class="p-3">Awarded By</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            // Sort by timestamp in descending order
            const sortedHistory = [...historyData].sort((a, b) => b.timestamp - a.timestamp);

            sortedHistory.forEach(point => {
                const date = new Date(point.timestamp * 1000).toLocaleString(); // Convert to milliseconds
                const reasonTitle = point.note ? `title="${point.note}"` : ''; // Add a tooltip with the note if it exists
                
                // Determine the correct suffix and color for the points display
                let pointsText;
                let pointsClass = '';
                
                if (point.reason === "Decay") {
                    pointsText = `-${point.points}%`;
                    pointsClass = 'decay-points';
                } else if (point.type === "EP") {
                    pointsText = `${point.points} EP`;
                    pointsClass = 'ep-points';
                } else if (point.type === "GP") {
                    pointsText = `${point.points} GP`;
                    pointsClass = 'gp-points';
                } else {
                    // Fallback for any other unexpected data
                    pointsText = `${point.points}`;
                }
                
                tableHTML += `
                    <tr class="border-b border-gray-700 last:border-b-0 even:bg-gray-800">
                        <td class="p-3 text-sm whitespace-nowrap">${date}</td>
                        <td class="p-3 text-sm">${point.player}</td>
                        <td class="p-3 text-sm font-bold"><span class="${pointsClass}">${pointsText}</span></td>
                        <td class="p-3 text-sm" ${reasonTitle}>${point.reason}</td>
                        <td class="p-3 text-sm">${point.awardedBy}</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHTML;
        }

        // NOTE: This function now receives an array of loot objects directly
        function displayLootHistoryTable(historyData, container) {
            if (!historyData || historyData.length === 0) {
                container.innerHTML = '<p class="text-center text-gray-400">No loot history to display yet.</p>';
                return;
            }

            let tableHTML = `
                <table class="w-full text-left rounded-lg overflow-hidden">
                    <thead class="bg-[#e32636] text-white">
                        <tr>
                            <th class="p-3">Time</th>
                            <th class="p-3">Player</th>
                            <th class="p-3">Cost</th>
                            <th class="p-3">Item</th>
                            <th class="p-3">Awarded By</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            // Sort by timestamp in descending order
            const sortedHistory = [...historyData].sort((a, b) => b.timestamp - a.timestamp);

            sortedHistory.forEach(item => {
                const date = new Date(item.timestamp * 1000).toLocaleString(); // Convert to milliseconds
                const qualityClass = item.quality ? `quality-${item.quality}` : '';
                
                // Construct the Wowhead-compatible link using the actual item.id from the data.
                // The new check ensures we only create a link if the id exists.
                const itemLink = item.id ? 
                    `<a href="https://www.wowhead.com/item=${item.id}" class="${qualityClass}" data-wh-icon-size="small" data-wh-rename-link="true">${item.name}</a>` :
                    `<span class="${qualityClass}">${item.name}</span>`;
                
                tableHTML += `
                    <tr class="border-b border-gray-700 last:border-b-0 even:bg-gray-800">
                        <td class="p-3 text-sm whitespace-nowrap">${date}</td>
                        <td class="p-3 text-sm">${item.player}</td>
                        <td class="p-3 text-sm font-bold"><span class="gp-points">${item.points} GP</span></td>
                        <td class="p-3 text-sm">${itemLink}</td>
                        <td class="p-3 text-sm">${item.awardedBy}</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHTML;
        }

        // Start the application when the window loads
        window.onload = initFirebase;
    </script>
</body>
</html>
